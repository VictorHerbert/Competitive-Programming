<!DOCTYPE html>
<html>
<head>
  <script src="https://lukakalinovcic.github.io/geodeb/main.js"></script>
</head>
<body>
  <div id="rootElement"></div>
</body>
<script type="text/javascript">
resourcePath = 'https://lukakalinovcic.github.io/geodeb/';
jsonData = 
{
  "source_code": [
    "#include <bits/stdc++.h>\u000a",
    "\u000a",
    "#ifndef ONLINE_JUDGE\u000a",
    "#include \u0022../Util/debug.h\u0022\u000a",
    "#include \u0022../Util/geo_debug.h\u0022\u000a",
    "#endif\u000a",
    "\u000a",
    "    using namespace std;\u000a",
    "\u000a",
    "const long double EPS = 1e-9;\u000a",
    "const int INF = INT_MAX / 4;\u000a",
    "const unsigned long long MOD = 1e9 + 7;\u000a",
    "\u000a",
    "#define ld long double\u000a",
    "#define ll long long\u000a",
    "\u000a",
    "inline bool D_EQ(ld a, ld b)\u000a",
    "{\u000a",
    "    return abs(a - b) < EPS;\u000a",
    "}\u000a",
    "#define all(x) x.begin(), x.end()\u000a",
    "#define rall(x) x.rbegin(), x.rend()\u000a",
    "#define FIND(v, c) find(v.begin(), v.end(), c) != v.end()\u000a",
    "#define FOR(i, a, b) for (int i = a; i < b; i++)\u000a",
    "#define REP(n) FOR(_, 0, n)\u000a",
    "inline int inRange(int i, int a, int b)\u000a",
    "{\u000a",
    "    return a <= i && i < b;\u000a",
    "}\u000a",
    "inline int inRange2D(int i, int j, int a, int b) { return inRange(i, 0, a) && inRange(j, 0, b); }\u000a",
    "inline int toidx(int i, int j, int n) { return i * n + j; }\u000a",
    "inline ld clamp(ld v, ld a, ld b) { return max(a, min(v, b)); }\u000a",
    "\u000a",
    "//----------------- Constants & Macros ------------------------------\u000a",
    "\u000a",
    "const ld PI = atan(1.0) * 4;\u000a",
    "const ld PI_2 = PI * 2;\u000a",
    "const ld DEG_to_RAD_CONST = PI / 180;\u000a",
    "const ld RAD_TO_DEG_CONST = 180 / PI;\u000a",
    "#define DEG_TO_RAD(x) x *DEG_to_RAD_CONST\u000a",
    "#define RAD_TO_DEG(x) x *RAD_TO_DEG_CONST\u000a",
    "#define hypot(x, y) sqrt(x *x + y * y)\u000a",
    "\u000a",
    "//----------------- Point ------------------------------\u000a",
    "\u000a",
    "struct Point\u000a",
    "{\u000a",
    "    ld x, y;\u000a",
    "\u000a",
    "    Point() { x = 0, y = 0; }\u000a",
    "    Point(ld _x, ld _y) : x(_x), y(_y) {}\u000a",
    "\u000a",
    "    Point operator+(Point other) const\u000a",
    "    {\u000a",
    "        return Point(x + other.x, y + other.y);\u000a",
    "    }\u000a",
    "    Point operator-(Point other) const\u000a",
    "    {\u000a",
    "        return Point(x - other.x, y - other.y);\u000a",
    "    }\u000a",
    "    Point operator*(ld k) const\u000a",
    "    {\u000a",
    "        return Point(x * k, y * k);\u000a",
    "    }\u000a",
    "\u000a",
    "    ld norm()\u000a",
    "    {\u000a",
    "        return hypot(x, y);\u000a",
    "    }\u000a",
    "\u000a",
    "    Point normalized()\u000a",
    "    {\u000a",
    "        return *this * (1 / norm());\u000a",
    "    }\u000a",
    "};\u000a",
    "\u000a",
    "// ax+by+c=0\u000a",
    "struct Line\u000a",
    "{\u000a",
    "    ld a, b, c;\u000a",
    "    Point p1, p2;\u000a",
    "    Point v;\u000a",
    "\u000a",
    "    Line() {}\u000a",
    "    Line(ld _a, ld _b, ld _c) : a(_a), b(_b), c(_c) {}\u000a",
    "    Line(Point _p1, Point _p2)\u000a",
    "    {\u000a",
    "        p1 = _p1, p2 = _p2;              // If b == 0 is vertical, b == 1 otherwise\u000a",
    "        if (abs(p1.x - p2.x) < EPS)      // Vertical\u000a",
    "            a = 1.0, b = 0.0, c = -p1.x; // default values\u000a",
    "        else\u000a",
    "        {\u000a",
    "            a = -(p1.y - p2.y) / (p1.x - p2.x);\u000a",
    "            b = 1.0;\u000a",
    "            c = -(a * p1.x) - p1.y;\u000a",
    "        }\u000a",
    "        v = p1 - p2;\u000a",
    "    }\u000a",
    "\u000a",
    "    ld angCoef()\u000a",
    "    {\u000a",
    "        return -a / b;\u000a",
    "    }\u000a",
    "    ld ang()\u000a",
    "    {\u000a",
    "        return atan(this->angCoef());\u000a",
    "    }\u000a",
    "    ld offset()\u000a",
    "    {\u000a",
    "        return -c / b;\u000a",
    "    }\u000a",
    "};\u000a",
    "\u000a",
    "// a1x + b1y + c1 = 0 and a2x + b2y + c2 = 0.\u000a",
    "Point intersectPoint(Line &l1, Line &l2)\u000a",
    "{\u000a",
    "    Point p;\u000a",
    "\u000a",
    "    p.x = (l2.b * l1.c - l1.b * l2.c) / (l2.a * l1.b - l1.a * l2.b);\u000a",
    "\u000a",
    "    if (abs(l1.b) > EPS) // If vertical\u000a",
    "        p.y = -(l1.a * p.x + l1.c);\u000a",
    "    else\u000a",
    "        p.y = -(l2.a * p.x + l2.c);\u000a",
    "\u000a",
    "    return p;\u000a",
    "}\u000a",
    "bool insideSeg(Line l, Point r)\u000a",
    "{\u000a",
    "    return ((min(l.p1.x, l.p2.x) <= r.x) and (min(l.p1.y, l.p2.y) <= r.y) and (max(l.p1.x, l.p2.x) >= r.x) and (max(l.p1.y, l.p2.y) >= r.y));// and D_EQ(r.y, (-l.c - l.a * r.x) / l.b);\u000a",
    "}\u000a",
    "\u000a",
    "bool intersectsSegSeg(Line s, Line l)\u000a",
    "{\u000a",
    "    Point p = intersectPoint(s, l);\u000a",
    "    return insideSeg(s, p) and insideSeg(l, p);\u000a",
    "}\u000a",
    "\u000a",
    "inline void plotSeg(Line l)\u000a",
    "{\u000a",
    "    GD_SEGMENT(\u000a",
    "        l.p1.x, l.p1.y,\u000a",
    "        l.p2.x, l.p2.y);\u000a",
    "}\u000a",
    "\u000a",
    "int main()\u000a",
    "{\u000a",
    "    GD_INIT(\u0022../Util/debug.html\u0022);\u000a",
    "    int n;\u000a",
    "    Point p1, p2;\u000a",
    "    Line l, l1, l2, l3, l4;\u000a",
    "    ld x1, x2, y1, y2;\u000a",
    "    cin >> n;\u000a",
    "\u000a",
    "    REP(n){\u000a",
    "        cin >> p1.x >> p1.y >> p2.x >> p2.y;\u000a",
    "        cin >> x1 >> y1 >> x2 >> y2;\u000a",
    "\u000a",
    "        if((p1.x == p2.x) and (p1.y == p2.y)){\u000a",
    "            GD_POINT(p1);\u000a",
    "            continue;\u000a",
    "        }\u000a",
    "\u000a",
    "        l = Line(p1, p2);\u000a",
    "\u000a",
    "        l1 = Line(Point(x1, y1), Point(x1, y2));\u000a",
    "        l2 = Line(Point(x1, y1), Point(x2, y1));\u000a",
    "        l3 = Line(Point(x2, y2), Point(x1, y2));\u000a",
    "        l4 = Line(Point(x2, y2), Point(x2, y1));\u000a",
    "        plotSeg(l1);\u000a",
    "        plotSeg(l2);\u000a",
    "        plotSeg(l3);\u000a",
    "        plotSeg(l4);\u000a",
    "        plotSeg(l);\u000a",
    "\u000a",
    "        //GD_POINT(p1);\u000a",
    "\u000a",
    "        if (\u000a",
    "            intersectsSegSeg(l, l1) or\u000a",
    "            intersectsSegSeg(l, l2) or\u000a",
    "            intersectsSegSeg(l, l3) or\u000a",
    "            intersectsSegSeg(l, l4))\u000a",
    "            cout << \u0022T\u005cn\u0022;\u000a",
    "        else\u000a",
    "            cout << \u0022F\u005cn\u0022;\u000a",
    "    }\u000a",
    "\u000a",
    "    return 0;\u000a",
    "}\u000a",
    "\u000a",
    "//g++ -std=c++11 ../Template/stdGeo.cpp -o s.exe & s.exe < in.txt > out.txt"
  ],
  "root": {
    "type": "begin",
    "line": 148,
    "children": [
      {
        "type": "segment",
        "line": 143,
        "x1": 1.000000,
        "y1": 4.000000,
        "x2": 1.000000,
        "y2": 1.000000
      },
      {
        "type": "segment",
        "line": 143,
        "x1": 1.000000,
        "y1": 4.000000,
        "x2": 6.000000,
        "y2": 4.000000
      },
      {
        "type": "segment",
        "line": 143,
        "x1": 6.000000,
        "y1": 1.000000,
        "x2": 1.000000,
        "y2": 1.000000
      },
      {
        "type": "segment",
        "line": 143,
        "x1": 6.000000,
        "y1": 1.000000,
        "x2": 6.000000,
        "y2": 4.000000
      },
      {
        "type": "segment",
        "line": 143,
        "x1": 3.000000,
        "y1": 3.000000,
        "x2": 2.000000,
        "y2": 2.000000
      }
    ]
  },
  "theme": "light"
};
init(resourcePath);
</script>
</html>
